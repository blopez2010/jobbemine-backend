type Query {
  getOpportunities(offset: Int!, size: Int!): OpportunityPayload
  getPeople(offset: Int!, size: Int!): PeoplePayload
}

type OpportunityPayload implements PayloadBase {
  offset: Int
  results: [OpportunityResultInput!]!
  size: Int
  total: Int
}

type PeoplePayload implements PayloadBase {
  offset: Int
  results: [PeopleInput!]!
  size: Int
  total: Int 
}

type PeopleInput {
  context: [ContextInput]
  _meta: PeopleMetaInput
  compensations: PeopleCompensationInput
  locationName: String!
  name: String!
  openTo: [String]
  picture: String
  professionalHeadline: String!
  remoter: Boolean!
  skills: [SkillInput]
  subjectId: String!
  username: String!
  verified: Boolean!
  weight: Float
}

type OpportunityResultInput {
  id: String!
  objective: String!
  type: String!
  organizations: [OrganizationInput!]
  locations: [String!]
  remote: Boolean!
  external: Boolean!
  deadline: String!
  status: String!
  compensation: CompensationDataInput!
  skills: [SkillInput!]
  members: [MemberInput!]
  questions: [QuestionInput!]
  context: [ContextInput]
  _meta: Meta!
}

type ContextInput {
  signaled: [String]
}

type CompensationDataInput {
  data: CompensationInput!
  visible: Boolean!
}

type PeopleCompensationInput {
  freelancer: CompensationInput
  employees: CompensationInput
}

type CompensationInput {
  code: String
  currency: String!
  minAmount: Float
  maxAmount: Float
  periodicity: String!
  amount: Float
}

type OrganizationInput {
  id: Int!
  name: String!
  picture: String!
}

type SkillInput {
  name: String!
  experience: String
  weight: Float
}

type MemberInput {
  subjectId: String!
  name: String!
  username: String!
  professionalHeadline: String!
  picture: String!
  member: Boolean!
  manager: Boolean!
  posters: Boolean!
  weight: Float!
}

type QuestionInput {
  id: String!
  text: String!
  date: String!
}

type Meta {
  rank: Float!
  scorer: ScorerInput
  filter: String
  boosters: [String]
}

type PeopleMetaInput {
  rank: Float!
  score: Float
  And: PeopleAndInput
}

type ScorerInput {
  score: Float!
  and: AndInput
}

type AndInput {
  id: String
  input: Input
}

type PeopleAndInput {
  rank: Float
  scorer: String
  score: Float
  input: Input
}

type Input {
  criteria: String
  opportunity: OpportunityInput
  person: PersonInput
}

type PersonInput {
  weight: Float!
}

type OpportunityInput {
  completion: Float
}

interface PayloadBase {
  offset: Int
  size: Int
  total: Int
}